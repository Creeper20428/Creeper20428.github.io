// Utility function to copy an array
function arrayCopy(a){
	var r = [];
	for(var i=0;i<a.length;i++){
		r[i] = a[i];
	}
	return r;
}
// Utility function to find if these are factors.
function isFactor(a,b){
	return (a%b==0);
}
// Utility "quadratic equation" function
// Reference:
//
//                    ____________
//                 2 /
//        -b (+/-) \/ (b*b) - 4ac
//       -------------------------
//   x =             2a
// There are 2 solutions
function quadraticEquation(a,b,c){
	var x1 = (-(b)+Math.sqrt((b*b)-(4*a*c)))/(2*a);
	var x2 = (-(b)-Math.sqrt((b*b)-(4*a*c)))/(2*a);
	return [x1,x2];
}
/*!
 * GCF.js:Simple GCF.
 * @author: Joey Kim
 */
// Utility function to find factors.
function findFactors(integer){
	var factors = [];
	var quotient = 0;

 	for(var i = 1; i <= integer; i++){
		quotient = integer/i;

    	if(quotient === Math.floor(quotient)){
    		factors.push(i); 
    	}
	}
	return factors;
}
// Utility function to reorganize the array generated by findFactors
function reorganize(array){
	var factorGroups = [];
	for(var i=0;i<array.length;i++){
		// i: First index.
		// j: Opposite index.
		var j = array.length - 1 - i;
		if(i>j) break;
		factorGroups.push([array[i],array[j]]);
	}
	return factorGroups;
}
function GCF(a, b) {
    if (a == 0)
        return b;

    while (b != 0) {
        if (a > b)
            a = a - b;
        else
            b = b - a;
    }

    return a;
}
// GCF of letters.
function GCL(a,b){
	var gcl = "";
	if(a == undefined || b == undefined){
		throw "Internal Error: a or b does not exist!!!";
	}
	if(a.length < b.length){
		for(var i=0;i<b.length-1;i++){
			for(var j=0;j<a.length;j++){
				if(b[i] == a[j]){
					if((b[j] == undefined) || (a[i] == undefined)){
						continue;
					}
					gcl+=b[i];
				}
			}
		}
	}else{
		for(var i=0;i<a.length;i++){
			for(var j=0;j<b.length;j++){
				if(a[i] == b[j]){
					if((b[i] == undefined) || (a[j] == undefined)){
						continue;
					}
					gcl+=b[i];
				}
			}
		}
	}
	return gcl;
}
/*!
 * AlgebraExp.js:Parse Algebraic expressions.
 * @author: Joey Kim
 */
/**
 * Syntax: new AlgebraicExpression("2x");
 * @param {String} string
 */
function AlgebraicExpression(string){
	this.constants = null;
	this.variables = [];
	var constStr = "";
	var arr = string.split("");
	var i=0;
	do{
		console.log(arr[i]);
		constStr += arr[i];
		i++;
	}while(__utils.isDigit(arr[i]));
	// slurp up rest of the variables.
	for(var j=i;i<arr.length;i++){
		this.variables.push(arr[i]);
	}
	this.constants = parseInt(constStr);
}
// Useful
AlgebraicExpression.prototype.toString = function(){
	return this.constants + this.variables.join("");
};
var __utils = {
	isDigit: function(c){
		return !(isNaN(parseInt(c)));
	},
	isCharacter: function(c){
		return !(isNaN(parseInt(c)));
	}
};
/*
 * Factoring.js:A Quadratic factoring program.
 * ax(squared) + bx + c
 */
function factor(a,b,c){
	var x,y,z;
	if(!a) x = 1; else x = a; // x squared.
	if(!b) y = 0; else y = b;// 0bx (0)
	if(!c) z = 0; else z = c;// 0 (0)



	if(!b && !c){
		throw "Factoring error: b and c must not be 0.";
	}
	if(a==0){
		throw "Quadratic Equation Error: a cannot be 0!";
	}
	var pair = null;
	// Find factors
	var d = reorganize(findFactors(a*c));
	// Loop through them to see if one pair = b.
	for(var e = 0; e < d.length; e++){
		console.log(d[e][0] , d[e][1]);
		if(d[e][0] + d[e][1] == b){
			console.log("here");
			pair = arrayCopy(d[e]);
			console.log(pair);
			break;
		}
	} 
	if(pair == null){
		console.log("Not factorable.");
		return quadraticEquation(x,y,z);
	}
	// The diamond problem is solved!
	// \     /
	//  \a b/
	//   \ /
	//  a X b
	//   / \
	//  /a+b\
	// /     \
	var roots = [], factored = ""; // Roots of the quadratic 
	console.log(pair,x);
	if(x == 1){
		// You don't need to waste time with a generic rectangle.
		
		console.log(pair);
		
		console.log(pretty_print(pair,"simple"));
		
		console.log(solve(pair,"simple"));
		
		factored = pretty_print(pair,"simple");
		
		roots = solve(pair,"simple");
	}
	else{
		// *sigh* Generic rectangle time.
		// NOTES:
		// Sides indexes: TOP: 0, 1; SIDE: 2,4
		// Top
		var  f =        [     0, 0,
						  0, [0, 0],
						  0, [0, 0]
						];
		// Object representation (used)
		//     0   1
		//   +---+---+
		// 0 | 0 | 1 |
		//   +---+---+
		// 1 | 2 | 3 |
		//   +---+---+
		f = {
			// Multipliers
			top: [0,0],
			side: [0,0],
			// In rectangle.
			rectangle : [0,0,0,0]
		};
		// Put in Variables.
		// TOP LEFT
		f.rectangle[0] = new AlgebraicExpression(x + "xx");
		// TOP RIGHT
		f.rectangle[1] = new AlgebraicExpression(pair[0] + "x");
		// BOTTOM LEFT
		f.rectangle[2] = new AlgebraicExpression(pair[1] + "x");
		// BOTTOM RIGHT
		f.rectangle[3] = new AlgebraicExpression(z.toString());
		// Now find GCF.
		// TODO: Use GCF & AlgebraicExp to find const and vars.
		//TOP  0   1
		//   +---+---+
		// 0 | 0 | 1 |
		//   +---+---+
		// 1 | 2 | 3 |
		//   +---+---+
		// Find top array.
		f.top[0] = GCF(f.rectangle[0].constants,f.rectangle[2].constants)+GCL(f.rectangle[0].variables.join(""),f.rectangle[2].variables.join(""));
		f.top[1] = GCF(f.rectangle[1].constants,f.rectangle[3].constants)+GCL(f.rectangle[1].variables.join(""),f.rectangle[3].variables.join(""));
		// Sides
		f.side[0] = GCF(f.rectangle[0].constants,f.rectangle[1].constants)+GCL(f.rectangle[0].variables.join(""),f.rectangle[1].variables.join(""));
		f.side[1] = GCF(f.rectangle[2].constants,f.rectangle[3].constants)+GCL(f.rectangle[2].variables.join(""),f.rectangle[3].variables.join(""));
		console.log([f.top,f.side]);
		console.log(pretty_print([f.top,f.side],"complex"));
		console.log(solve([f.top,f.side],"complex"));
		roots = solve([f.top,f.side],"complex");
		factored = pretty_print([f.top,f.side],"complex");
	}
	// We have the roots.SS
	showwork(x,y,z,pair,factored,roots,f);
}
// Step 2: Pretty print
function pretty_print(arr,type){
	if(type == "simple"){
		return "(x + " + arr[0] + ")(x + " + arr[1] + ") = 0";
	}else if(type == "complex"){
		return "("+ arr[0][0] + " + " + arr[0][1] + ")(" + arr[1][0] + " + " + arr[1][1] + ") = 0";
	}
}
// Step 3: Solve
// FORMULA:
// if (Ax+B)=0...
//    B
// - ===
//    A
function solve(arr,type){
	if(type == "simple"){
		return [-arr[0],-arr[1]];
	}else if(type == "complex"){
		// TODO: SOLVE
		// Use AlgebraicExpression to get constants.
		var a1 = new AlgebraicExpression(arr[0][0]).constants;
		var b1 = new AlgebraicExpression(arr[0][1]).constants;
		var a2 = new AlgebraicExpression(arr[1][0]).constants;
		var b2 = new AlgebraicExpression(arr[1][1]).constants;
		return [-(b1/a1),-(b2/a2)];
	}
}
// Step 4: Show "all" Work.
function showwork(a,b,c,diamond_problem,factored,roots,f){
	// Work element creation
	if(!document.getElementById("work")){
		var elt = document.createElement("pre");
	}else{
		var elt = document.getElementById("work");
	}
	// We need div.
	if(elt.nodeType !== "PRE"){
		var e = document.createElement("pre");
		elt.appendChild(e);
	}else{
		var e = elt;
	}
	// Set font style.
	e.style.fontFamily = "monospace";
	work = "Diamond problem:\n";
	// WRITE WORK
	work += "TOP:    " + a + "x{SQUARED}"+"\n";
	work += "LEFT:   " + diamond_problem[0]+"\n";
	work += "RIGHT:  " + diamond_problem[1]+"\n";
	work += "BOTTOM: " + b + "x"+"\n";
	work += "\n";
	work += "FACTORED EQUATION:";
	work += factored+"\n";
	work += "\n";
	if(f){
		work += "GENERIC RECTANGLE:\n";
		work += "TOP/BORROM FACTORS: " + f.top.join(";")+"\n";
		work += "SIDE/SIDE FACTORS: " + f.side.join(";")+"\n";
		work += "RECTANGLE" +"\n";
		console.log(f.rectangle);
		work += "ROW 1: " + f.rectangle[0] + " , " +  f.rectangle[2]+"\n";
		work += "ROW 2: " + f.rectangle[1] + " , " +  f.rectangle[3]+"\n";
	}
	work += "ROOTS: " + roots.join(";");
	e.innerHTML = work;
	elt.appendChild(e);
	document.body.appendChild(e);
}
